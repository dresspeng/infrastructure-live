name: Scraper

on:
  workflow_dispatch:
    inputs:
      environment:
        type: environment
        description: "The environment to deploy to"
        required: true
        default: repositories
      running:
        type: boolean
        description: "Up and running"
        required: true
        default: true

env:
  # TERRAFORM_VERSION: 1.4.6
  # TERRAGRUNT_VERSION: 0.45.17
  ECR_PRIVACY: ${{ vars.CONTAINER_REGISTRY_PRIVACY }}
  IMAGE_TAG: latest
  ORG: ${{ github.repository_owner }}
  BRANCH: ${{ github.head_ref || github.ref_name }}

jobs:
  ecr:
    name: setup ECR
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'repositories' }}
    env:
      ECR_REGISTRY_PRIVATE_URI: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION_NAME }}.amazonaws.com
      ECR_REGISTRY_PUBLIC_URI: public.ecr.aws
    outputs:
      ECR_REPOSITORY_NAME: ${{ steps.get-output.outputs.ECR_REPOSITORY_NAME }}
      ECR_LOGIN_PASSWORD: ${{ steps.get-output.outputs.ECR_LOGIN_PASSWORD }}
      ECR_REGISTRY_URI: ${{ steps.get-output.outputs.ECR_REGISTRY_URI }}

    steps:
      - name: setup AWS CLI
        run: |
          aws --version
          aws configure set aws_access_key_id ${{ vars.AWS_ACCESS_KEY }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_KEY }}
          aws configure set region ${{ vars.AWS_REGION_NAME }}

      - name: Get ECR information
        id: get-output
        run: |
          REPO=$(basename ${{ github.repository }})
          echo "ECR_REPOSITORY_NAME=$(echo $REPO-$BRANCH | tr A-Z a-z)" >> $GITHUB_OUTPUT

          if [[ $ECR_PRIVACY == private ]]; then
            echo "ECR_LOGIN_PASSWORD=$(aws ecr get-login-password --region $AWS_REGION_NAME)" >> $GITHUB_OUTPUT
            echo "ECR_REGISTRY_URI=$ECR_REGISTRY_PRIVATE_URI" >> $GITHUB_OUTPUT            
          elif [[ $ECR_PRIVACY == public ]]; then
            echo "ECR_LOGIN_PASSWORD=$(aws ecr-public get-login-password --region us-east-1)" >> $GITHUB_OUTPUT
            echo "ECR_REGISTRY_URI=$ECR_REGISTRY_PUBLIC_URI" >> $GITHUB_OUTPUT  
          fi

  # Container network where we can access with the service name and the port
  project:
    name: Container check
    needs: [ecr]
    runs-on: ubuntu-latest
    container: ubuntu # connect the workflow steps to the network
    environment: ${{ inputs.environment || 'repositories' }}
    env:
      HEALTHCHECK: /healthz
    services:
      local-project:
        image: ${{ needs.ecr.outputs.ECR_REGISTRY_URI }}/${{ needs.ecr.outputs.ECR_REPOSITORY_NAME}}
        # options: --read-only
        credentials:
          username: AWS
          password: ${{ needs.ecr.outputs.ECR_LOGIN_PASSWORD }}
        env:
          AWS_REGION_NAME: ${{ vars.AWS_REGION_NAME }}
          AWS_PROFILE_NAME: ${{ vars.AWS_PROFILE_NAME }}
          AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
          AWS_ACCESS_KEY: ${{ vars.AWS_ACCESS_KEY }}
          AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
          REPOSITORIES_AWS_REGION_NAME: ${{ vars.AWS_REGION_NAME }}
          REPOSITORIES_AWS_PROFILE_NAME: ${{ vars.AWS_PROFILE_NAME }}
          REPOSITORIES_AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
          REPOSITORIES_AWS_ACCESS_KEY: ${{ vars.AWS_ACCESS_KEY }}
          REPOSITORIES_AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Setup AWS CLI
        id: setup
        run: |
          make aws-auth


# jobs:
#   scraper:
#     runs-on: ubuntu-latest
#     environment: ${{ inputs.environment || 'repositories' }}
#     env:
#       DOCKER_IMAGE_NAME: this-image
#       ECR_PRIVACY: private  # fetch from each repo vars
#       ECR_REGISTRY_PRIVATE_URI: ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION_NAME }}.amazonaws.com
#       ECR_REGISTRY_PUBLIC_URI: public.ecr.aws
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v3

#       - name: Setup privacy env
#         run: |
#           if [[ $ECR_PRIVACY == private ]]; then
#             AWS_CLI_SERVICE=ecr
#             ECR_REGISTRY_URI=$ECR_REGISTRY_PRIVATE_URI
#           elif [[ $ECR_PRIVACY == public ]]; then
#             AWS_CLI_SERVICE=ecr-public
#             ECR_REGISTRY_URI=$ECR_REGISTRY_PUBLIC_URI
#           fi

#           echo AWS_CLI_SERVICE=$AWS_CLI_SERVICE
#           echo AWS_CLI_SERVICE=$AWS_CLI_SERVICE >> $GITHUB_ENV

#           echo ECR_REGISTRY_URI=$ECR_REGISTRY_URI
#           echo ECR_REGISTRY_URI=$ECR_REGISTRY_URI >> $GITHUB_ENV

#       - name: Setup AWS CLI        
#         run: |
#           # make aws-auth \
#           #   AWS_PROFILE_NAME=${{ vars.AWS_PROFILE_NAME }} \
#           #   AWS_REGION_NAME=${{ vars.AWS_REGION_NAME }} \
#           #   AWS_ACCESS_KEY=${{ vars.AWS_ACCESS_KEY }} \
#           #   AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }} \
#           #   REPOSITORIES_AWS_PROFILE_NAME=${{ vars.AWS_PROFILE_NAME }} \
#           #   REPOSITORIES_AWS_REGION_NAME=${{ vars.AWS_REGION_NAME }} \
#           #   REPOSITORIES_AWS_ACCESS_KEY=${{ vars.AWS_ACCESS_KEY }} \
#           #   REPOSITORIES_AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}

#           aws --version
#           aws configure set aws_access_key_id ${{ vars.AWS_ACCESS_KEY }}
#           aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_KEY }}
#           aws configure set region ${{ vars.AWS_REGION_NAME }}
#           aws configure list

#       - name: Login to ${{ vars.CONTAINER_REGISTRY_PRIVACY }} ECR
#         uses: docker/login-action@v2
#         with:
#           registry: ${{ env.ECR_REGISTRY_URI }}

#       - uses: webfactory/ssh-agent@v0.8.0
#         with:
#           ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

#       - name: Setup Terraform v${{ env.TERRAFORM_VERSION }}
#         uses: hashicorp/setup-Terraform@v2
#         with:
#           terraform_version: ${{ env.TERRAFORM_VERSION }}
#           terraform_wrapper: false

#       - name: Setup Terraform version
#         run: terraform --version

#       - name: Setup Terraform wrapper path
#         run: which terraform
#       - name: Setup Terragrunt v${{ env.TERRAGRUNT_VERSION }}
#         run: |
#           sudo wget -q -O /bin/terragrunt "https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64"
#           sudo chmod +x /bin/terragrunt
#           terragrunt -v

      - name: Terragrunt prepare
        id: prepare
        run: |
          make prepare-terragrunt \
            DOMAIN_NAME=${{ vars.DOMAIN_NAME }}  \
            AWS_REGION_NAME=${{ vars.AWS_REGION_NAME }} \
            AWS_PROFILE_NAME=${{ vars.AWS_PROFILE_NAME }}  \
            AWS_ACCOUNT_ID=${{ vars.AWS_ACCOUNT_ID }} \
            REPOSITORIES_AWS_REGION_NAME=${{ vars.AWS_REGION_NAME }} \
            REPOSITORIES_AWS_PROFILE_NAME=${{ vars.AWS_PROFILE_NAME }}  \
            REPOSITORIES_AWS_ACCOUNT_ID=${{ vars.AWS_ACCOUNT_ID }}

      - name: Terragrunt backend
        id: backend
        run: |
          TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/backend

          make prepare-scraper-backend \
            GITHUB_TOKEN=${{ secrets.GH_TERRA_TOKEN}} \
            TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH} \
            BRANCH_NAME=${{ github.head_ref || github.ref_name }}  \
            FLICKR_PRIVATE_KEY=${{ secrets.FLICKR_PRIVATE_KEY }} \
            FLICKR_PUBLIC_KEY=${{ secrets.FLICKR_PUBLIC_KEY }} \
            UNSPLASH_PRIVATE_KEY=${{ secrets.UNSPLASH_PRIVATE_KEY }} \
            UNSPLASH_PUBLIC_KEY=${{ secrets.UNSPLASH_PUBLIC_KEY }} \
            PEXELS_PUBLIC_KEY=${{ secrets.PEXELS_PUBLIC_KEY }} \
            AWS_REGION_NAME=${{ vars.AWS_REGION_NAME }} \
            AWS_ACCESS_KEY=${{ vars.AWS_ACCESS_KEY }} \
            AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}

          make -f Makefile_infra init TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH}

          if [[ ${{ inputs.running }} == false ]]; then
            make -f Makefile_infra destroy-microservice TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH}
          else            
            make -f Makefile_infra apply TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH}

            BACKEND_DNS_URL=$(make -f Makefile_infra output-microservice TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH})
            if [[ -z ${BACKEND_DNS_URL} ]]; then
              echo -e '\033[41mBACKEND_DNS_URL\033[0m' ::: ${BACKEND_DNS_URL}
              exit 42
            else
              echo -e '\033[44mBACKEND_DNS_URL\033[0m' ::: ${BACKEND_DNS_URL}
            fi
            echo BACKEND_DNS_URL=$BACKEND_DNS_URL >> $GITHUB_ENV
          fi

      - name: Terragrunt frontend
        id: frontend
        run: |
          export TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/frontend

          make prepare-scraper-frontend \
            GITHUB_TOKEN=${{ secrets.GH_TERRA_TOKEN}} \
            TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH} \
            BRANCH_NAME=${{ github.head_ref || github.ref_name }}  \
            NEXT_PUBLIC_API_URL=${BACKEND_DNS_URL}

          make -f Makefile_infra init TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH}

          if [[ ${{ inputs.running }} == false ]]; then
            make -f Makefile_infra destroy-microservice TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH}
          else
            make -f Makefile_infra apply TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH}

            FRONTEND_DNS_URL=$(make -f Makefile_infra output-microservice TERRAGRUNT_CONFIG_PATH=${TERRAGRUNT_CONFIG_PATH})
            if [[ -z ${FRONTEND_DNS_URL} ]]; then
              echo -e '\033[41mFRONTEND_DNS_URL\033[0m' ::: ${FRONTEND_DNS_URL}
              exit 42
            else
              echo -e '\033[44mFRONTEND_DNS_URL\033[0m' ::: ${FRONTEND_DNS_URL}
            fi
            echo FRONTEND_DNS_URL=$FRONTEND_DNS_URL >> $GITHUB_ENV
          fi

      # # run container like backend and frontend with dynamic port
      # # FIXME: do not use terraform at all, only terragrunt
      # - name: Build docker image
      #   run: |
      #     docker build --progress=plain -t $DOCKER_IMAGE_NAME -f Dockerfile .

      # - name: Scraper
      #   run: |
      #     docker run \
      #       -v /tmp:/tmp \
      #       --user 1001:1001 \
      #       --env AWS_REGION_NAME=${{ vars.AWS_REGION_NAME }} \
      #       --env AWS_PROFILE_NAME=${{ vars.AWS_PROFILE_NAME }} \
      #       --env AWS_ACCESS_KEY=${{ vars.AWS_ACCESS_KEY }} \
      #       --env AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }} \
      #       --env AWS_ACCOUNT_ID=${{ vars.AWS_ACCOUNT_ID }} \
      #       --env GITHUB_TOKEN=${{ secrets.GH_TERRA_TOKEN }} \
      #       --env SSH_PRIVATE_KEY="${{ secrets.SSH_PRIVATE_KEY }}" \
      #       --env SSH_PUBLIC_KEY="${{ vars.SSH_PUBLIC_KEY }}" \
      #       --env INPUT_RUNNING=${{ inputs.running }} \
      #       --env BRANCH_NAME=${{ github.head_ref || github.ref_name }} \
      #       --env DOMAIN_NAME=${{ vars.DOMAIN_NAME }} \
      #       --env FLICKR_PRIVATE_KEY=${{ secrets.FLICKR_PRIVATE_KEY }} \
      #       --env FLICKR_PUBLIC_KEY=${{ secrets.FLICKR_PUBLIC_KEY }} \
      #       --env UNSPLASH_PRIVATE_KEY=${{ secrets.UNSPLASH_PRIVATE_KEY }} \
      #       --env UNSPLASH_PUBLIC_KEY=${{ secrets.UNSPLASH_PUBLIC_KEY }} \
      #       --env PEXELS_PUBLIC_KEY=${{ secrets.PEXELS_PUBLIC_KEY }} \
      #       $DOCKER_IMAGE_NAME \
      #       /bin/bash -c '

      #         # tmp ownership
      #         sudo mkdir -p /tmp/out
      #         sudo chown 1001:1001 /tmp/out
      #         sudo chmod g+s /tmp/out
      #         ls -l /tmp/out

      #         # aws
      #         make aws-auth

      #         # github token
      #         make gh-auth-check

      #         # ssh
      #         eval `ssh-agent -s`
      #         mkdir -p ~/.ssh
      #         SSH_FOLDER=$(cd ~/.ssh; pwd)
      #         echo ${SSH_FOLDER}
      #         echo "${SSH_PRIVATE_KEY}" > ~/.ssh/action
      #         echo "${SSH_PUBLIC_KEY}" > ~/.ssh/action.pub
      #         sudo chmod -R 600 ${SSH_FOLDER}/action
      #         ssh-add ~/.ssh/action
      #         ssh-keyscan github.com >> ~/.ssh/known_hosts
      #         cat ~/.ssh/known_hosts

      #         # terragrunt
      #         make prepare-terragrunt \
      #           DOMAIN_NAME=${DOMAIN_NAME} \
      #           AWS_REGION_NAME=${AWS_REGION_NAME} \
      #           AWS_PROFILE_NAME=${AWS_PROFILE_NAME} \
      #           AWS_ACCOUNT_ID=${AWS_ACCOUNT_ID}

      #         # backend
      #         make prepare-scraper-backend \
      #           TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/backend \
      #           BRANCH_NAME=${BRANCH_NAME} \
      #           FLICKR_PRIVATE_KEY=${FLICKR_PRIVATE_KEY} \
      #           FLICKR_PUBLIC_KEY=${FLICKR_PUBLIC_KEY} \
      #           UNSPLASH_PRIVATE_KEY=${UNSPLASH_PRIVATE_KEY} \
      #           UNSPLASH_PUBLIC_KEY=${UNSPLASH_PUBLIC_KEY} \
      #           PEXELS_PUBLIC_KEY=${PEXELS_PUBLIC_KEY} \
      #           AWS_REGION_NAME=${AWS_REGION_NAME} \
      #           AWS_ACCESS_KEY=${AWS_ACCESS_KEY} \
      #           AWS_SECRET_KEY=${AWS_SECRET_KEY}
      #         make init TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/backend
      #
      #         if [[ ${INPUT_RUNNING} == false ]]; then
      #           make destroy-microservice TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/backend
      #         else
      #           make apply TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/backend
      #         fi

      #         # frontend
      #         export NEXT_PUBLIC_API_URL=$(terraform output -state=live/aws/region/scraper/backend/terraform.tfstate -json  microservice | jq '.ecs.elb.lb_dns_name')
      #         echo BACKEND DNS URL ::: ${NEXT_PUBLIC_API_URL}
      #         make prepare-scraper-frontend \
      #           TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/frontend \
      #           BRANCH_NAME=${BRANCH_NAME} \
      #           NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
      #         make init TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/frontend
      #
      #         if [[ ${INPUT_RUNNING} == false ]]; then
      #           make destroy-microservice TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/frontend
      #         else
      #           make apply TERRAGRUNT_CONFIG_PATH=live/aws/region/scraper/frontend
      #         fi
      #         '